{"version":3,"sources":["webpack://generator/webpack/bootstrap","webpack://generator/./node_modules/sudoku-core/src/sudoku-core.js","webpack://generator/./node_modules/sudoku-solver/dist/solver.js","webpack://generator/./src/generator.js"],"names":["generate","difficulty","completedPuzzle","createCompletedPuzzle","numHolesToDig","getNumGivens","digPuzzle","createFixedValsFromState","state","map","row","val","numGivens","initState","newState","addRandomValuesToState","fixedVals","result","completedState","numVals","x","getRandom","y","allowed","getRandomArrayVal","lowerBound","upperBound","Math","floor","random","arr","length","numGivensRanges","min","max","numToDig","undiggableCells","randY","randX","digCell","newUndiggableCells","givenVal","otherVals","filter","every"],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AClFA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8CAA8C;AAC9C,uCAAuC;AACvC,iDAAiD;AACjD,2DAA2D;AAC3D;AACA,qCAAqC;AACrC;AACA;AACA,mEAAmE;AACnE,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1JA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF,wHAAwH,mBAAmB,EAAE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B,EAAE;AAC/D,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,8DAA8D,+DAA+D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V,iCAAiC,oFAAoF;;AAErH,6BAA6B,6EAA6E;;AAE1G,wCAAwC,eAAe,eAAe,gBAAgB,oBAAoB,MAAM,0CAA0C,+BAA+B,aAAa,qBAAqB,mCAAmC,EAAE,EAAE,cAAc,WAAW,UAAU,EAAE,UAAU,MAAM,iDAAiD,EAAE,UAAU,kBAAkB,EAAE,EAAE,aAAa;;AAEvZ,+BAA+B,oCAAoC;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;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","file":"generator.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/generator.js\");\n","// Returns all of the values in the same row, column, and square of a given coordinate\nexport const getAdjacentValues = (state, coord) => {\n  const [y, x] = coord;\n  const xVals = state[y];\n  const yVals = state.map(row => row[x]);\n  const squareVals = getValues(state, getSquareCoords(getSquare(y, x)));\n  return {x: xVals, y: yVals, squareVals: squareVals};\n};\n\nexport function getInitState(fillVal = null) {\n  return Array(9).fill([]).map(() => [...(Array(9).fill(fillVal))]);\n}\n\n// Returns all of the coordinates in the same row, column, and square of a given coordinate\nexport const getAdjacentCoords = (coord) => {\n  const [y, x] = coord;\n  const xCoords = [0,1,2,3,4,5,6,7,8].map(y => [y, x]).filter(coord => coord[0] !== y);\n  const yCoords = [0,1,2,3,4,5,6,7,8].map(x => [y, x]).filter(coord => coord[1] !== x);\n  const squareCoords = getSquareCoords(getSquare(y, x))\n    .filter(coord => coord[0] !== y || coord[1] !== x);\n  return {x: xCoords, y: yCoords, squareCoords: squareCoords};\n};\n\nexport const getAllowed = (state, coord) => {\n  const adjacent = getAdjacentValues(state, coord);\n  const adjacentVals = [].concat(adjacent.x, adjacent.y, adjacent.squareVals);\n  return [1,2,3,4,5,6,7,8,9].filter(num => {\n    return !adjacentVals.includes(num);\n  });\n};\n\nexport const arraysAreIdentical = (arr1, arr2) => {\n  if (!Array.isArray(arr1) || !Array.isArray(arr2)) return undefined;\n  if (arr1.length !== arr2.length) return false;\n\n  for (let i = arr1.length; i--;) {\n    if (Array.isArray(arr1[i]) || Array.isArray(arr2[i])) {\n      if (!arraysAreIdentical(arr1[i], arr2[i])) {\n        return false;\n      }\n    } else if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport const isSolved = (state) => ![].concat(...state).includes(null);\n\nexport const isValidPuzzle = (state) => {\n  const flatState = state.reduce((flatState, row) => flatState.concat(row), []);\n  if (!flatState.includes(null)) return false;  // a valid puzzle must have at least one blank cell\n  if (state.length !== 9) return false;  // Must have 9 rows\n  const hasInvalidVals = state.some((row, y) => {  // return whether any cell values are not allowed for their coordinate\n    if (state.some((row) => row.length !== 9)) return true;  // Must have 9 columns\n    return row.some((val, x) => {\n      if (val === null) return false;  // Ignore empty cells\n      const stateCopy = copyState(state);\n      stateCopy[y][x] = null;\n      return getAllowed(stateCopy, [y, x]).includes(val) === false;  // If cell val isn't in allowed vals, return true\n    });\n  });\n  return !hasInvalidVals;\n};\n\nexport const checkSolutionIsValid = (state) => {\n  const valsAreValid = (arr) => {\n    return arraysAreIdentical([1,2,3,4,5,6,7,8,9], arr.slice().sort());\n  };\n\n  const rows = state;\n  const cols = [0,1,2,3,4,5,6,7,8].map(x => state.map(row => row[x]));\n  const squares = [1,2,3,4,5,6,7,8,9].map(square => getValues(state, getSquareCoords(square)));\n\n  const rowsValid = rows.every(valsAreValid);\n  const colsValid = cols.every(valsAreValid);\n  const squaresValid = squares.every(valsAreValid);\n\n  return rowsValid && colsValid && squaresValid;\n};\n\n// const copyState = (state)  => state.map(arr => [...arr]);\nexport function copyState(state) {\n  // if (Array.isArray(state)) return state.slice().map(val => copyState(val));\n  // Switched to FOR loop for performance\n  let i, copy;\n  if (Array.isArray(state)) {\n    copy = state.slice();\n    for (i = 0; i < copy.length; i++) {\n      copy[i] = copyState(copy[i]);\n    }\n    return copy;\n  }\n  if (state !== null && typeof state === 'object') return false;  // You can't clone an object this way\n  return state;\n}\n\nexport const printState = (state) => {\n  return state.reduce((text, row, index) => {\n    if (index === 3 || index === 6) {\n      text = text.concat(\"\\n\");  // Add horizontal spacing\n    }\n    const rowString = row.reduce((rowText, val, rowIndex) => {\n      val = val === null ? '_' : val;\n      if (rowIndex === 3 || rowIndex === 6) {\n        rowText = rowText.concat(' ');  // Add vertical spacing\n      }\n      return rowText.concat(' ' + val);\n    }, '');\n    return text.concat(\"|\" + rowString + \" |\\n\");\n  }, '');\n};\n\nconst isValidValue = (val) => [1,2,3,4,5,6,7,8,9].includes(val);\n\nconst getValues = (state, coordinates) => {\n  return coordinates.map(coord => getValue(state, coord));\n};\n\n// Get the value of a given coordinate from the given puzzle state\nconst getValue = (state, coordinate) => state[coordinate[0]][coordinate[1]];\n\n// Get the square (1 through 9) that contains the given coordinates\n// TODO: Consider caching square/coordinate maps to save performance\nconst getSquare = (y, x) => {\n  return [1,2,3,4,5,6,7,8,9].find(square => {\n    return getSquareCoords(square).some(coord => {\n      return arraysAreIdentical(coord, [y, x]);\n    });\n  });\n};\n\n// Get the coordinates contained within in a given square (1 through 9)\nconst getSquareCoords = (square) => {\n  return squareCoordMap[square];\n};\n\nexport const parseState = (inputState) => {\n  return inputState.map(row => {\n    return row.map(val => isValidValue(val) ? val : null);\n  });\n};\n\n// Map of squares to the coordinates they contain\nconst squareCoordMap = {\n  1:[[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]],\n  2:[[0,3],[0,4],[0,5],[1,3],[1,4],[1,5],[2,3],[2,4],[2,5]],\n  3:[[0,6],[0,7],[0,8],[1,6],[1,7],[1,8],[2,6],[2,7],[2,8]],\n  4:[[3,0],[3,1],[3,2],[4,0],[4,1],[4,2],[5,0],[5,1],[5,2]],\n  5:[[3,3],[3,4],[3,5],[4,3],[4,4],[4,5],[5,3],[5,4],[5,5]],\n  6:[[3,6],[3,7],[3,8],[4,6],[4,7],[4,8],[5,6],[5,7],[5,8]],\n  7:[[6,0],[6,1],[6,2],[7,0],[7,1],[7,2],[8,0],[8,1],[8,2]],\n  8:[[6,3],[6,4],[6,5],[7,3],[7,4],[7,5],[8,3],[8,4],[8,5]],\n  9:[[6,6],[6,7],[6,8],[7,6],[7,7],[7,8],[8,6],[8,7],[8,8]],\n};\n","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/solver.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/solver.js\":\n/*!***********************!*\\\n  !*** ./src/solver.js ***!\n  \\***********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = solve;\n\nvar _sudokuCore = __webpack_require__(/*! ./sudoku-core */ \"./src/sudoku-core.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar nextCell = function nextCell(curY, curX) {\n  if (curX === 8 && curY === 8) return undefined;\n  if (curX === 8) return [curY + 1, 0];\n  return [curY, curX + 1];\n};\n\nvar getValidAllowed = function getValidAllowed(state, _ref, invalidVals) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      y = _ref2[0],\n      x = _ref2[1];\n\n  return (0, _sudokuCore.getAllowed)(state, [y, x]).filter(function (val) {\n    return !invalidVals[y][x].includes(val);\n  });\n};\n\nfunction solve(state, _ref3, invalidVals, fixedVals) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n      y = _ref4[0],\n      x = _ref4[1];\n\n  if (fixedVals[y][x] === 'fixed') {\n    if (y === 8 && x === 8) return {\n      solved: true,\n      completedState: state\n    };\n\n    var _nextCell = nextCell(y, x),\n        _nextCell2 = _slicedToArray(_nextCell, 2),\n        _nextY = _nextCell2[0],\n        _nextX = _nextCell2[1];\n\n    return solve(state, [_nextY, _nextX], invalidVals, fixedVals);\n  }\n\n  var allowedVals = getValidAllowed(state, [y, x], invalidVals);\n  if (!allowedVals.length) return false;\n  var tryVal = allowedVals[0]; // TODO: randomize which allowedVal we use to prevent bias towards lower numbers\n\n  var newState = (0, _sudokuCore.copyState)(state);\n  newState[y][x] = tryVal;\n  if (y === 8 && x === 8) return {\n    solved: true,\n    completedState: newState\n  };\n\n  var _nextCell3 = nextCell(y, x),\n      _nextCell4 = _slicedToArray(_nextCell3, 2),\n      nextY = _nextCell4[0],\n      nextX = _nextCell4[1];\n\n  var result = solve(newState, [nextY, nextX], invalidVals, fixedVals);\n  if (_typeof(result) === 'object' && result.solved === true) return result;\n\n  if (result === false) {\n    invalidVals[y][x] = invalidVals[y][x].concat(tryVal); // TODO: make immutable\n\n    var newInvalid = (0, _sudokuCore.copyState)(invalidVals).map(function (invRow, invY) {\n      // Remove old state\n      if (invY > y) return invRow.fill([]);\n      if (invY === y) return invRow.fill([], x + 1);\n      return invRow;\n    });\n    newState = undefined; // TODO: Test to see if making these undefined actually reduces memory use\n\n    invalidVals = undefined;\n    result = undefined;\n    return solve(state, [y, x], newInvalid, fixedVals);\n  }\n}\n\n/***/ }),\n\n/***/ \"./src/sudoku-core.js\":\n/*!****************************!*\\\n  !*** ./src/sudoku-core.js ***!\n  \\****************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getInitState = getInitState;\nexports.copyState = copyState;\nexports.parseState = exports.printState = exports.checkSolutionIsValid = exports.isValidPuzzle = exports.isSolved = exports.arraysAreIdentical = exports.getAllowed = exports.getAdjacentCoords = exports.getAdjacentValues = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n// Returns all of the values in the same row, column, and square of a given coordinate\nvar getAdjacentValues = function getAdjacentValues(state, coord) {\n  var _coord = _slicedToArray(coord, 2),\n      y = _coord[0],\n      x = _coord[1];\n\n  var xVals = state[y];\n  var yVals = state.map(function (row) {\n    return row[x];\n  });\n  var squareVals = getValues(state, getSquareCoords(getSquare(y, x)));\n  return {\n    x: xVals,\n    y: yVals,\n    squareVals: squareVals\n  };\n};\n\nexports.getAdjacentValues = getAdjacentValues;\n\nfunction getInitState() {\n  var fillVal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return Array(9).fill([]).map(function () {\n    return _toConsumableArray(Array(9).fill(fillVal));\n  });\n} // Returns all of the coordinates in the same row, column, and square of a given coordinate\n\n\nvar getAdjacentCoords = function getAdjacentCoords(coord) {\n  var _coord2 = _slicedToArray(coord, 2),\n      y = _coord2[0],\n      x = _coord2[1];\n\n  var xCoords = [0, 1, 2, 3, 4, 5, 6, 7, 8].map(function (y) {\n    return [y, x];\n  }).filter(function (coord) {\n    return coord[0] !== y;\n  });\n  var yCoords = [0, 1, 2, 3, 4, 5, 6, 7, 8].map(function (x) {\n    return [y, x];\n  }).filter(function (coord) {\n    return coord[1] !== x;\n  });\n  var squareCoords = getSquareCoords(getSquare(y, x)).filter(function (coord) {\n    return coord[0] !== y || coord[1] !== x;\n  });\n  return {\n    x: xCoords,\n    y: yCoords,\n    squareCoords: squareCoords\n  };\n};\n\nexports.getAdjacentCoords = getAdjacentCoords;\n\nvar getAllowed = function getAllowed(state, coord) {\n  var adjacent = getAdjacentValues(state, coord);\n  var adjacentVals = [].concat(adjacent.x, adjacent.y, adjacent.squareVals);\n  return [1, 2, 3, 4, 5, 6, 7, 8, 9].filter(function (num) {\n    return !adjacentVals.includes(num);\n  });\n};\n\nexports.getAllowed = getAllowed;\n\nvar arraysAreIdentical = function arraysAreIdentical(arr1, arr2) {\n  if (!Array.isArray(arr1) || !Array.isArray(arr2)) return undefined;\n  if (arr1.length !== arr2.length) return false;\n\n  for (var i = arr1.length; i--;) {\n    if (Array.isArray(arr1[i]) || Array.isArray(arr2[i])) {\n      if (!arraysAreIdentical(arr1[i], arr2[i])) {\n        return false;\n      }\n    } else if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexports.arraysAreIdentical = arraysAreIdentical;\n\nvar isSolved = function isSolved(state) {\n  var _ref;\n\n  return !(_ref = []).concat.apply(_ref, _toConsumableArray(state)).includes(null);\n};\n\nexports.isSolved = isSolved;\n\nvar isValidPuzzle = function isValidPuzzle(state) {\n  var flatState = state.reduce(function (flatState, row) {\n    return flatState.concat(row);\n  }, []);\n  if (!flatState.includes(null)) return false; // a valid puzzle must have at least one blank cell\n\n  if (state.length !== 9) return false;\n  var hasInvalidVals = state.some(function (row, y) {\n    // return whether any cell values are not allowed for their coordinate\n    if (state.some(function (row) {\n      return row.length !== 9;\n    })) return true;\n    return row.some(function (val, x) {\n      var stateCopy = copyState(state);\n      stateCopy[y][x] = null;\n      return getAllowed(stateCopy, [y, x]).includes(val);\n    }) === false;\n  });\n  return !hasInvalidVals;\n};\n\nexports.isValidPuzzle = isValidPuzzle;\n\nvar checkSolutionIsValid = function checkSolutionIsValid(state) {\n  var valsAreValid = function valsAreValid(arr) {\n    return arraysAreIdentical([1, 2, 3, 4, 5, 6, 7, 8, 9], arr.slice().sort());\n  };\n\n  var rows = state;\n  var cols = [0, 1, 2, 3, 4, 5, 6, 7, 8].map(function (x) {\n    return state.map(function (row) {\n      return row[x];\n    });\n  });\n  var squares = [1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (square) {\n    return getValues(state, getSquareCoords(square));\n  });\n  var rowsValid = rows.every(valsAreValid);\n  var colsValid = cols.every(valsAreValid);\n  var squaresValid = squares.every(valsAreValid);\n  return rowsValid && colsValid && squaresValid;\n}; // const copyState = (state)  => state.map(arr => [...arr]);\n\n\nexports.checkSolutionIsValid = checkSolutionIsValid;\n\nfunction copyState(state) {\n  // if (Array.isArray(state)) return state.slice().map(val => copyState(val));\n  // Switched to FOR loop for performance\n  var i, copy;\n\n  if (Array.isArray(state)) {\n    copy = state.slice();\n\n    for (i = 0; i < copy.length; i++) {\n      copy[i] = copyState(copy[i]);\n    }\n\n    return copy;\n  }\n\n  if (state !== null && _typeof(state) === 'object') return false; // You can't clone an object this way\n\n  return state;\n}\n\nvar printState = function printState(state) {\n  return state.reduce(function (text, row, index) {\n    if (index === 3 || index === 6) {\n      text = text.concat(\"\\n\"); // Add horizontal spacing\n    }\n\n    var rowString = row.reduce(function (rowText, val, rowIndex) {\n      val = val === null ? '_' : val;\n\n      if (rowIndex === 3 || rowIndex === 6) {\n        rowText = rowText.concat(' '); // Add vertical spacing\n      }\n\n      return rowText.concat(' ' + val);\n    }, '');\n    return text.concat(\"|\" + rowString + \" |\\n\");\n  }, '');\n};\n\nexports.printState = printState;\n\nvar isValidValue = function isValidValue(val) {\n  return [1, 2, 3, 4, 5, 6, 7, 8, 9].includes(val);\n};\n\nvar getValues = function getValues(state, coordinates) {\n  return coordinates.map(function (coord) {\n    return getValue(state, coord);\n  });\n}; // Get the value of a given coordinate from the given puzzle state\n\n\nvar getValue = function getValue(state, coordinate) {\n  return state[coordinate[0]][coordinate[1]];\n}; // Get the square (1 through 9) that contains the given coordinates\n// TODO: Consider caching square/coordinate maps to save performance\n\n\nvar getSquare = function getSquare(y, x) {\n  return [1, 2, 3, 4, 5, 6, 7, 8, 9].find(function (square) {\n    return getSquareCoords(square).some(function (coord) {\n      return arraysAreIdentical(coord, [y, x]);\n    });\n  });\n}; // Get the coordinates contained within in a given square (1 through 9)\n\n\nvar getSquareCoords = function getSquareCoords(square) {\n  return squareCoordMap[square];\n};\n\nvar parseState = function parseState(inputState) {\n  return inputState.map(function (row) {\n    return row.map(function (val) {\n      return isValidValue(val) ? val : null;\n    });\n  });\n}; // Map of squares to the coordinates they contain\n\n\nexports.parseState = parseState;\nvar squareCoordMap = {\n  1: [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]],\n  2: [[0, 3], [0, 4], [0, 5], [1, 3], [1, 4], [1, 5], [2, 3], [2, 4], [2, 5]],\n  3: [[0, 6], [0, 7], [0, 8], [1, 6], [1, 7], [1, 8], [2, 6], [2, 7], [2, 8]],\n  4: [[3, 0], [3, 1], [3, 2], [4, 0], [4, 1], [4, 2], [5, 0], [5, 1], [5, 2]],\n  5: [[3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5], [5, 3], [5, 4], [5, 5]],\n  6: [[3, 6], [3, 7], [3, 8], [4, 6], [4, 7], [4, 8], [5, 6], [5, 7], [5, 8]],\n  7: [[6, 0], [6, 1], [6, 2], [7, 0], [7, 1], [7, 2], [8, 0], [8, 1], [8, 2]],\n  8: [[6, 3], [6, 4], [6, 5], [7, 3], [7, 4], [7, 5], [8, 3], [8, 4], [8, 5]],\n  9: [[6, 6], [6, 7], [6, 8], [7, 6], [7, 7], [7, 8], [8, 6], [8, 7], [8, 8]]\n};\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=solver.js.map","import {getAllowed, copyState, getInitState} from '../node_modules/sudoku-core/src/sudoku-core';\nimport solve from '../node_modules/sudoku-solver/dist/solver';\n\nexport const generate = (difficulty = 'medium') => {\n  const completedPuzzle = createCompletedPuzzle();\n  if (completedPuzzle === false) return generate(difficulty);\n  const numHolesToDig = 81 - getNumGivens(difficulty);\n  return digPuzzle(completedPuzzle, numHolesToDig, getInitState());\n};\n\nconst createFixedValsFromState = (state) => {\n  return state.map(row => row.map(val => val === null ? null : 'fixed'));\n};\n\nconst createCompletedPuzzle = () => {\n  const numGivens = 11;\n  const initState = getInitState();\n  const newState = addRandomValuesToState(initState, numGivens);\n  const fixedVals = createFixedValsFromState(newState);\n  const result = solve(newState, [0,0], getInitState([]), fixedVals);\n  return result.completedState;\n};\n\nfunction addRandomValuesToState(state, numVals = 1) {\n  if (numVals === 0) return state;\n  const x = getRandom(0, 8);\n  const y = getRandom(0, 8);\n  if (state[y][x] !== null) return addRandomValuesToState(state, numVals);  // If already added a value here, try again\n  const allowed = getAllowed(state, [y, x]);\n  state[y][x] = getRandomArrayVal(allowed);\n  return addRandomValuesToState(state, numVals - 1);\n}\n\nconst getRandom = (lowerBound = 1, upperBound = 9) => {\n  return Math.floor(Math.random() * (upperBound - lowerBound + 1)) + lowerBound;\n};\n\nconst getRandomArrayVal = (arr) => {\n  return arr[getRandom(0, arr.length - 1)];\n};\n\nconst getNumGivens = (difficulty) => {\n  const numGivensRanges = {\n    'very_easy': [50, 55],\n    'easy': [36, 49],\n    'medium': [32, 35],\n    'hard': [28, 31],\n    'very_hard': [22, 27],\n  };\n  const [min, max] = numGivensRanges[difficulty];\n  return getRandom(min, max);\n};\n\nfunction digPuzzle(state, numToDig, undiggableCells) {\n  if (numToDig === 0) return state;\n  const randY = getRandom(0, 8);\n  const randX = getRandom(0, 8);\n  if (state[randY][randX] === null || undiggableCells[randY][randX] === true) return digPuzzle(state, numToDig, undiggableCells);\n  const result = digCell(state, [randY, randX]);\n  if (result === false) {\n    const newUndiggableCells = copyState(undiggableCells);\n    newUndiggableCells[randY][randX] = true;\n    return digPuzzle(state, numToDig, newUndiggableCells);\n  }\n  const newState = copyState(state);\n  newState[randY][randX] = null;\n  return digPuzzle(newState, numToDig - 1, undiggableCells);\n}\n\nconst digCell = (state, [y, x]) => {\n  const givenVal = state[y][x];\n  const otherVals = [1,2,3,4,5,6,7,8,9].filter(val => val === givenVal);\n  return otherVals.every(val => {\n    const newState = copyState(state);\n    newState[y][x] = val;\n    return solve(newState, [0, 0], getInitState([]), getInitState()) === false;\n  });\n};\n\n// const prevCell = () => {\n//   if (x === 0 && y === 0) return undefined;\n//   if (x === 0) return [y - 1, 0];\n//   return [y, x - 1];\n// };"],"sourceRoot":""}